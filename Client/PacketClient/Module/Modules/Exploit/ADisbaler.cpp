#include "ADisabler.h"

void ADisabler::onPlayerTick(C_Player* plr) {
	int server = Server.selected;
	if (!packetLook) {
		if (onlyOnBuildMods) {
			// modules with build capabilities

			// crystalauras
			bool CPlace = moduleMgr->getModule<CrystalPlace>()->isEnabled();
			bool CABPG = moduleMgr->getModule<CrystalAura>()->isEnabled();
			bool CAOW = moduleMgr->getModule<CrystalAura>()->isEnabled();
			bool CAWTA = moduleMgr->getModule<CrystalAuraWTA>()->isEnabled();
			bool Se = moduleMgr->getModule<CrystalAura>()->isEnabled();

			// holefiller
			bool HF = moduleMgr->getModule<HoleFiller>()->isEnabled();
			//bool SB = moduleMgr->getModule<PistonAura>()->isEnabled();
			bool sb2 = moduleMgr->getModule<Dupe>()->isEnabled();

			// surround
			bool jtwdSurr = moduleMgr->getModule<Surround>()->isEnabled();
			bool renSurr = moduleMgr->getModule<RenSurround>()->isEnabled();
			bool burr = moduleMgr->getModule<Burrow>()->isEnabled();

			// scaffold
			bool scaf = moduleMgr->getModule<Scaffold>()->isEnabled();
			bool tower = moduleMgr->getModule<Tower>()->isEnabled();

			// specials
			bool AnvA = moduleMgr->getModule<AnvilAura>()->isEnabled();
			bool AncA = moduleMgr->getModule<AnchorAura>()->isEnabled();
			bool trap = moduleMgr->getModule<AutoTrap>()->isEnabled();

			if (not(CPlace || CABPG || CAOW || CAWTA || HF || jtwdSurr || scaf || AnvA || AncA || trap || renSurr || burr || sb2 || tower))
				return;  // none of the above modules were enabled
		}

		if (GameData::isRightClickDown()) {
			if (pauseOnXP) {
				if ((g_Data.getLocalPlayer()->getSelectedItemId() == 508 || g_Data.getLocalPlayer()->getSelectedItemId() == 374))
					return;
			}

			if (pauseOnBow) {
				if (g_Data.getLocalPlayer()->getSelectedItemId() == 374 == 300)
					return;
			}

			//if (GameData::isLeftClickDown() && pauseOnMine)
				//return;

		}

	}

	// here's the actual main part; its short af
	plr->pitch = angle;
	PointingStruct* pstruct = g_Data.getLocalPlayer()->getPointingStruct();
	vec3_t block = pstruct->block.toVector3();
	int id = g_Data.getLocalPlayer()->region->getBlock(pstruct->block)->toLegacy()->blockId;

	if (id != 0 && (plr->pitch = -90))
		sb = true;
}
void ADisabler::onSendPacket(C_Packet* packet) {
	//int server = Server.selected;
	//(server == 1 && packet->isInstanceOf<PlayerAuthInputPacket>()); 
	//	PlayerAuthInputPacket* packet1 = (PlayerAuthInputPacket*)packet;
	//	packet1->velocity = vec3_t(0, 0, 0);
}

void ADisabler::onPostRender(C_MinecraftUIRenderContext* renderCtx) {
	auto player = g_Data.getLocalPlayer();
	if (player == nullptr) return;
	float scale = 2.5f;
	vec3_t EZ;
	vec3_t b1;
	vec3_t b2;
	vec3_t b3;
	vec3_t b4;
	EZ = g_Data.getLocalPlayer()->eyePos0;  // Block below the player
	b1 = EZ.add(0, -1, 0);
	b2 = EZ.add(-2, -1, 0);
	b3 = EZ.add(-1, -1, 1);
	b4 = EZ.add(-1, -1, -1);
	//top = EZ.add(-1, 1, 0);
	int bb1 = g_Data.getLocalPlayer()->region->getBlock(b1)->toLegacy()->blockId;
	int bb2 = g_Data.getLocalPlayer()->region->getBlock(b2)->toLegacy()->blockId;
	int bb3 = g_Data.getLocalPlayer()->region->getBlock(b3)->toLegacy()->blockId;
	int bb4 = g_Data.getLocalPlayer()->region->getBlock(b4)->toLegacy()->blockId;
	//int tt = g_Data.getLocalPlayer()->region->getBlock(top)->toLegacy()->blockId;
	//C_Block* block = gm->player->region->getBlock(blockPos);
	PointingStruct* pstruct = g_Data.getLocalPlayer()->getPointingStruct();
	vec3_t block = pstruct->block.toVector3();
	//C_ItemStack item = pstruct->rayHitType();
	//C_PlayerInventoryProxy* supplies = player->getSupplies();
	//C_ItemStack* item = &pstruct->block.toVector3();
	int id = g_Data.getLocalPlayer()->region->getBlock(pstruct->block)->toLegacy()->blockId;
	std::string sbb = "isBlock";
	std::string sbbn = "isAir";
	std::string safe = "Safe";
	std::string unsafe = "Unsafe";
	std::string head = "Head";
	std::string nhead = "NoHead";
	//float armorX = 5;
	//float armorY = 30;
	vec4_t testRect = vec4_t(100, 120, 135, 130);
	vec2_t armorPos = vec2_t(testRect.x, testRect.y);
	vec4_t testRect2 = vec4_t(100, 140, 135, 150);
	vec2_t armorPos2 = vec2_t(testRect2.x, testRect2.y);
	vec4_t testRect3 = vec4_t(100, 160, 110, 170);
	vec2_t armorPos3 = vec2_t(testRect3.x, testRect3.y);
	vec4_t testRect4 = vec4_t(100, 100, 135, 110);
	vec2_t armorPos4 = vec2_t(testRect4.x, testRect4.y);
	if (checkhead) {
		if (id != 0) {
			DrawUtils::drawText(armorPos, &sbb, MC_Color(255, 255, 255, 120), 1, true);
			DrawUtils::fillRoundRectangle(testRect, MC_Color(255, 0, 0, 120), false);
		}
		else
		{
			DrawUtils::drawText(armorPos, &sbbn, MC_Color(255, 255, 255, 120), 1, true);
			DrawUtils::fillRoundRectangle(testRect, MC_Color(0, 255, 0, 120), false);
		}
	}
	if (pauseOnMine) {
		if (bb1 != 0 && bb2 != 0 && bb3 != 0 && bb4 != 0) {
			DrawUtils::drawText(armorPos2, &safe, MC_Color(255, 255, 255, 120), 1, true);
			DrawUtils::fillRoundRectangle(testRect2, MC_Color(0, 255, 0, 120), false);
		}
		else {
			DrawUtils::drawText(armorPos2, &unsafe, MC_Color(255, 255, 255, 120), 1, true);
			DrawUtils::fillRoundRectangle(testRect2, MC_Color(255, 0, 0, 120), false);
		}
		{
			C_ItemStack* stack = g_Data.getLocalPlayer()->getSelectedItem();
			if (stack->item != nullptr) {
				DrawUtils::drawItem(stack, armorPos3, 1.f, scale, stack->isEnchanted());
				DrawUtils::fillRectangleA(testRect3, MC_Color(255, 255, 0, 0));
			}

		}




	}
}

