#include "ADisabler.h"

void ADisabler::onPlayerTick(C_Player* plr) {
	int server = Server.selected;
	if (!packetLook) {
		if (onlyOnBuildMods) {
			// modules with build capabilities

			// crystalauras
			bool CPlace = moduleMgr->getModule<CrystalPlace>()->isEnabled();
			bool CABPG = moduleMgr->getModule<CrystalAura>()->isEnabled();
			bool CAOW = moduleMgr->getModule<CrystalAura>()->isEnabled();
			bool CAWTA = moduleMgr->getModule<CrystalAuraWTA>()->isEnabled();
			bool Se = moduleMgr->getModule<CrystalAura>()->isEnabled();

			// holefiller
			bool HF = moduleMgr->getModule<HoleFiller>()->isEnabled();
			//bool SB = moduleMgr->getModule<PistonAura>()->isEnabled();
			bool sb2 = moduleMgr->getModule<Dupe>()->isEnabled();

			// surround
			bool jtwdSurr = moduleMgr->getModule<Surround>()->isEnabled();
			bool renSurr = moduleMgr->getModule<RenSurround>()->isEnabled();
			bool burr = moduleMgr->getModule<Burrow>()->isEnabled();

			// scaffold
			bool scaf = moduleMgr->getModule<Scaffold>()->isEnabled();
			bool tower = moduleMgr->getModule<Tower>()->isEnabled();

			// specials
			bool AnvA = moduleMgr->getModule<AnvilAura>()->isEnabled();
			bool AncA = moduleMgr->getModule<AnchorAura>()->isEnabled();
			bool trap = moduleMgr->getModule<AutoTrap>()->isEnabled();

			if (not(CPlace || CABPG || CAOW || CAWTA || HF || jtwdSurr || scaf || AnvA || AncA || trap || renSurr || burr || sb2 || tower))
				return;  // none of the above modules were enabled
		}

		if (GameData::isRightClickDown()) {
			if (pauseOnXP) {
				if ((g_Data.getLocalPlayer()->getSelectedItemId() == 508 || g_Data.getLocalPlayer()->getSelectedItemId() == 374))
					return;
			}

			if (pauseOnBow) {
				if (g_Data.getLocalPlayer()->getSelectedItemId() == 374 == 300)
					return;
			}

			//if (GameData::isLeftClickDown() && pauseOnMine)
				//return;

		}

	}
	// here's the actual main part; its short af
	plr->pitch = angle;
	PointingStruct* pstruct = g_Data.getLocalPlayer()->getPointingStruct();
	vec3_t block = pstruct->block.toVector3();
	int id = g_Data.getLocalPlayer()->region->getBlock(pstruct->block)->toLegacy()->blockId;

	if (id != 0 && (plr->pitch = -90))
		sb = true;
}
void ADisabler::onSendPacket(C_Packet* packet) {
	//int server = Server.selected;
	//(server == 1 && packet->isInstanceOf<PlayerAuthInputPacket>()); 
	//	PlayerAuthInputPacket* packet1 = (PlayerAuthInputPacket*)packet;
	//	packet1->velocity = vec3_t(0, 0, 0);
}

void ADisabler::onPostRender(C_MinecraftUIRenderContext* renderCtx) {
	PointingStruct* pstruct = g_Data.getLocalPlayer()->getPointingStruct();
	vec3_t block = pstruct->block.toVector3();
	//C_ItemStack item = pstruct->rayHitType();
	//C_PlayerInventoryProxy* supplies = player->getSupplies();
	//C_ItemStack* item = &pstruct->block.toVector3();
	int id = g_Data.getLocalPlayer()->region->getBlock(pstruct->block)->toLegacy()->blockId;
	std::string sbb = "Block";
	std::string sbbn = "Air";
	float sbbx = 40;
	float sbby = 50;
	//float armorX = 5;
	//float armorY = 30;
	vec4_t testRect = vec4_t(sbbx, sbby, 50 + sbbx, sbby + 10);
	vec2_t armorPos = vec2_t(testRect.x, testRect.y);
	if (checkhead) {
		if (id != 0) {
			DrawUtils::drawGradientText(armorPos, &sbb, 1, 1, true);
			DrawUtils::fillRoundRectangle(testRect, MC_Color(255, 0, 0, 150), false);
		}
		else
		{
			DrawUtils::drawGradientText(armorPos, &sbbn, 1, 1, true);
			DrawUtils::fillRoundRectangle(testRect, MC_Color(0, 255, 0, 150), false);
		}
	}
}
